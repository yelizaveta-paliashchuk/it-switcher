# Описание и основные отличия работы команд git pull и git fetch

Команды `git pull` и `git fetch` используются для получения изменений из удаленного репозитория в локальный репозиторий, но имеют некоторые ключевые отличия:

1. ### git fetch:

- Команда `git fetch` извлекает все изменения из удаленного репозитория, но не влияет на локальные ветки.
- После выполнения `git fetch` изменения сохраняются в локальной копии удаленных веток, но локальные ветки не обновляются автоматически.
- Это позволяет вам просмотреть изменения, которые были внесены в удаленном репозитории, но не объединять их с локальными ветками сразу.

2. ### git pull:

- Команда `git pull` извлекает изменения из удаленного репозитория и автоматически объединяет их с текущей локальной веткой.
- Она фактически выполняет команду `git fetch`, а затем `git merge` для объединения извлеченных изменений с текущей веткой.
- По умолчанию `git pull` связан с веткой, с которой вы клонировали репозиторий (обычно с веткой master), но вы можете указать конкретную ветку, используя `git pull origin <branch>`.
  Таким образом, основное отличие между `git fetch` и `git pull` заключается в том, что `git fetch` просто извлекает изменения и сохраняет их локально, в то время как `git pull` извлекает изменения и автоматически объединяет их с текущей веткой. Используйте `git fetch`, если вы хотите просмотреть изменения перед их объединением, и `git pull`, если вы уверены, что хотите автоматически объединить изменения с текущей веткой.

---

# Описание использования команды, позволяющей присоединить новые изменения в предыдущий коммит.

Чтобы присоединить новые изменения к предыдущему коммиту, вы можете использовать команду `git commit --amend`. Эта команда позволяет добавить изменения к последнему коммиту и изменить его сообщение, если это необходимо. Вот как это работает:

1. Внесите необходимые изменения в файлы вашего проекта.
2. Используйте `git add` для добавления измененных файлов в индекс: `git add <измененные файлы>`
3. Присоедините изменения к предыдущему коммиту: Используйте команду `git commit --amend`. После выполнения этой команды откроется редактор, где вы сможете изменить сообщение коммита (если это необходимо). После сохранения изменений в редакторе коммит будет изменен.
4. Пуш изменений: Если вы уже отправили коммит на удаленный репозиторий, вам может потребоваться использовать `git push --force` для обновления удаленной ветки. Обратите внимание, что использование `git push --force` изменит историю коммитов в удаленном репозитории, поэтому будьте осторожны с его применением, особенно если другие пользователи работают с этим репозиторием.

Эта команда полезна, когда вы хотите внести небольшие изменения или исправления к предыдущему коммиту без создания нового коммита. Однако ее следует использовать с осторожностью, особенно если вы уже отправили изменения на удаленный репозиторий, чтобы избежать потенциальных проблем с историей коммитов.

---

# Файл .gitignore

Это текстовый файл, который используется в системе контроля версий Git для указания файлов и каталогов, которые не должны быть отслеживаемыми Git. Когда Git встречает файл .gitignore, он игнорирует любые файлы или каталоги, указанные в этом файле, и не включает их в состояние проекта.

Вот несколько причин, почему мы используем _.gitignore_:

- **Исключение временных файлов и файлов сборки.**
  Во время разработки создаются различные временные и промежуточные файлы, такие как файлы журналов, файлы конфигурации среды разработки, исполняемые файлы и файлы, создаваемые инструментами сборки. Эти файлы не должны быть включены в репозиторий, и _.gitignore_ позволяет исключить их из отслеживания Git.
- **Скрытие конфиденциальных данных.**
  Некоторые файлы содержат конфиденциальные данные, такие как пароли, ключи доступа или файлы настроек, которые не должны быть общедоступными. Использование _.gitignore_ позволяет исключить такие файлы из репозитория.
- **Управление зависимостями.**
  Когда вы работаете с проектами на основе языков программирования или фреймворков, часто возникает необходимость в установке зависимостей и библиотек. Файлы, содержащие установленные зависимости, могут быть объемными и изменяться, и они обычно не должны включаться в репозиторий, чтобы избежать конфликтов при совместной работе над проектом. _.gitignore_ позволяет исключить такие файлы из отслеживания.
- **Улучшение производительности Git.**
  Исключение больших или временных файлов из отслеживания Git может улучшить производительность операций Git, таких как клонирование репозитория, синхронизация и проверка изменений.

Применение _.gitignore_ помогает поддерживать репозиторий чистым и управляемым, и упрощает совместную работу над проектами, уменьшая объем ненужных файлов и конфликтов, связанных с ними.

Подробнее изучить _.gitignore_ можно [на официальном сайте Git.](https://git-scm.com/docs/gitignore)

---

# Описание команды `git reset`

Команда `git reset` в Git используется для изменения состояния HEAD (указатель на текущую ветку) и/или состояния индекса (стэйджинг-области) и рабочего каталога.
Вот несколько основных случаев, когда команда `git reset` может быть полезна:

1. _Отмена изменений в стейджинг-области._ Если вы добавили файлы в стейджинг-область с помощью `git add`, но решили, что не хотите коммитить их, вы можете использовать `git reset`, чтобы убрать их из стейджинг-области. Например, `git reset <файл>` отменит добавление указанного файла.

2. _Перемещение HEAD к определённому коммиту._ Вы можете использовать git reset, чтобы переместить указатель HEAD к определённому коммиту, что позволит вам "перейти в прошлое" и начать работу от этой точки. Например, `git reset --hard HEAD~1` откатит HEAD к предыдущему коммиту.

3. _Изменение типа сброса (soft, mixed, hard)._ Команда `git reset` имеет различные режимы работы, такие как --soft, --mixed и --hard, позволяющие контролировать, какие изменения будут отменены и как. Например, `git reset --soft HEAD~1` вернёт вас к предыдущему коммиту, оставив ваши изменения в рабочем каталоге и индексе, готовые к повторному коммиту.

4. _Отмена нежелательных коммитов._ Вы можете использовать `git reset` для удаления одного или нескольких ненужных коммитов из истории коммитов. Это может быть полезно, когда вы сделали коммиты с ошибками или хотите изменить историю коммитов перед отправкой в удалённый репозиторий.

5. _Решение конфликтов слияний._ В случае возникновения конфликтов при слиянии веток, команда `git reset` может быть использована для перезапуска процесса слияния или перехода к другому состоянию репозитория.

В целом, `git reset` является мощной командой, позволяющей управлять состоянием вашего репозитория Git, отменять изменения и изменять историю коммитов. Однако она также может быть опасной, поэтому важно использовать её осторожно, особенно при выполнении команд с опцией `--hard`, которая может привести к потере данных.

---

# Проект на node.js с использованием npm и Jest

Этот тестовый проект содержит функции и модульные тесты с использованием npm и Jest.

## Установка

1. Сначала убедитесь, что у вас установлен Node.js. Можно загрузить и установить его с [официального сайта](https://nodejs.org/).

2. Клонируйте репозиторий с проектом на свой компьютер:

   `git clone https://github.com/yelizaveta-paliashchuk/it-switcher.git`

3. Перейдите в каталог проекта:

`cd your-project`

4. Установите зависимости, выполнив команду:

`npm install`

## Настройка

1. Установите JEST framework для выполнения юнит тестов в проект:

`npm install --save-dev jest`

2. Добавьте jest в package.json файл:

   `"scripts": {
 "test": "jest"
}`

3. Устновите плагин Istanbul для проверки покрытия кода юнит тестами:

`npm install --save-dev babel-plugin-istanbul`

## Запуск тестов

Для запуска тестов используйте команду:

`npm run test`

## Измерение покрытия кода тестами

Этот проект использует инструменты для анализа покрытия кода, такие как Istanbul или Jest, для измерения покрытия функций, веток и строк в коде.

После запуска тестов, откройте файл coverage\lcov-report\index.html с помощью Live Server (установите расширение в свой проект) чтобы увидеть отчет о покрытии кода в выполненных тестах.

---

## Отличие покрытия функций, веток и строк

### Покрытие функций (Functions)

Покрытие функций измеряет, сколько функций в вашем коде было вызвано во время выполнения тестов. Непокрытые функции могут указывать на неиспользованный или недостаточно протестированный код.

### Покрытие веток (Branches)

Покрытие веток измеряет, сколько ветвей (условий) в вашем коде было протестировано. Если условие в функции имеет две ветви (например, `if` и `else`), полное покрытие веток означает, что обе ветви были протестированы.

### Покрытие строк (Lines)

Покрытие строк измеряет, сколько строк в вашем коде было выполнено во время выполнения тестов. Непокрытые строки могут указывать на код, который не был выполнен или недостаточно протестирован.

## Интерпретация отчета о покрытии

- **100% покрытие**: Все функции, ветки и строки вашего кода были протестированы. Это обычно указывает на хорошо протестированный и здоровый код.
- **Неполное покрытие**: Некоторые функции, ветки или строки остались непротестированными. Это может указывать на потенциальные проблемы в вашем коде, которые требуют дополнительного тестирования.
- **Нулевое покрытие**: Ни одна функция, ветка или строка не была протестирована. Это может быть признаком неиспользуемого кода или отсутствия достаточных тестов.

Важно учитывать все три аспекта покрытия кода при оценке качества вашего тестового покрытия.
