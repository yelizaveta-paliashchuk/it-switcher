# Описание и основные отличия работы команд git pull и git fetch
Команды `git pull` и `git fetch` используются для получения изменений из удаленного репозитория в локальный репозиторий, но имеют некоторые ключевые отличия:
1. ### git fetch:
- Команда `git fetch` извлекает все изменения из удаленного репозитория, но не влияет на локальные ветки.
- После выполнения `git fetch` изменения сохраняются в локальной копии удаленных веток, но локальные ветки не обновляются автоматически.
- Это позволяет вам просмотреть изменения, которые были внесены в удаленном репозитории, но не объединять их с локальными ветками сразу.
2. ### git pull:
- Команда `git pull` извлекает изменения из удаленного репозитория и автоматически объединяет их с текущей локальной веткой.
- Она фактически выполняет команду `git fetch`, а затем `git merge` для объединения извлеченных изменений с текущей веткой.
- По умолчанию `git pull` связан с веткой, с которой вы клонировали репозиторий (обычно с веткой master), но вы можете указать конкретную ветку, используя `git pull origin <branch>`.
Таким образом, основное отличие между `git fetch` и `git pull` заключается в том, что `git fetch` просто извлекает изменения и сохраняет их локально, в то время как `git pull` извлекает изменения и автоматически объединяет их с текущей веткой. Используйте `git fetch`, если вы хотите просмотреть изменения перед их объединением, и `git pull`, если вы уверены, что хотите автоматически объединить изменения с текущей веткой.
---
# Описание использования команды, позволяющей присоединить новые изменения в предыдущий коммит. 
Чтобы присоединить новые изменения к предыдущему коммиту, вы можете использовать команду `git commit --amend`. Эта команда позволяет добавить изменения к последнему коммиту и изменить его сообщение, если это необходимо. Вот как это работает:
1. Внесите необходимые изменения в файлы вашего проекта.
2. Используйте `git add` для добавления измененных файлов в индекс: `git add <измененные файлы>`
3. Присоедините изменения к предыдущему коммиту: Используйте команду `git commit --amend`. После выполнения этой команды откроется редактор, где вы сможете изменить сообщение коммита (если это необходимо). После сохранения изменений в редакторе коммит будет изменен.
4. Пуш изменений: Если вы уже отправили коммит на удаленный репозиторий, вам может потребоваться использовать `git push --force` для обновления удаленной ветки. Обратите внимание, что использование `git push --force` изменит историю коммитов в удаленном репозитории, поэтому будьте осторожны с его применением, особенно если другие пользователи работают с этим репозиторием.

Эта команда полезна, когда вы хотите внести небольшие изменения или исправления к предыдущему коммиту без создания нового коммита. Однако ее следует использовать с осторожностью, особенно если вы уже отправили изменения на удаленный репозиторий, чтобы избежать потенциальных проблем с историей коммитов.

---
# Файл .gitignore 
Это текстовый файл, который используется в системе контроля версий Git для указания файлов и каталогов, которые не должны быть отслеживаемыми Git. Когда Git встречает файл .gitignore, он игнорирует любые файлы или каталоги, указанные в этом файле, и не включает их в состояние проекта.

Вот несколько причин, почему мы используем *.gitignore*:

* **Исключение временных файлов и файлов сборки.**
 Во время разработки создаются различные временные и промежуточные файлы, такие как файлы журналов, файлы конфигурации среды разработки, исполняемые файлы и файлы, создаваемые инструментами сборки. Эти файлы не должны быть включены в репозиторий, и *.gitignore* позволяет исключить их из отслеживания Git.
 * **Скрытие конфиденциальных данных.** 
 Некоторые файлы содержат конфиденциальные данные, такие как пароли, ключи доступа или файлы настроек, которые не должны быть общедоступными. Использование *.gitignore* позволяет исключить такие файлы из репозитория.
* **Управление зависимостями.** 
 Когда вы работаете с проектами на основе языков программирования или фреймворков, часто возникает необходимость в установке зависимостей и библиотек. Файлы, содержащие установленные зависимости, могут быть объемными и изменяться, и они обычно не должны включаться в репозиторий, чтобы избежать конфликтов при совместной работе над проектом. *.gitignore* позволяет исключить такие файлы из отслеживания.
* **Улучшение производительности Git.**
 Исключение больших или временных файлов из отслеживания Git может улучшить производительность операций Git, таких как клонирование репозитория, синхронизация и проверка изменений.

 Применение *.gitignore* помогает поддерживать репозиторий чистым и управляемым, и упрощает совместную работу над проектами, уменьшая объем ненужных файлов и конфликтов, связанных с ними.

 Подробнее изучить *.gitignore* можно [на официальном сайте Git.](https://git-scm.com/docs/gitignore)

 ---

# Описание команды `git reset`
Команда `git reset` в Git используется для изменения состояния HEAD (указатель на текущую ветку) и/или состояния индекса (стэйджинг-области) и рабочего каталога. 
Вот несколько основных случаев, когда команда `git reset` может быть полезна:

1. *Отмена изменений в стейджинг-области.* Если вы добавили файлы в стейджинг-область с помощью `git add`, но решили, что не хотите коммитить их, вы можете использовать `git reset`, чтобы убрать их  из стейджинг-области. Например, `git reset <файл>` отменит добавление указанного файла.

2. *Перемещение HEAD к определённому коммиту.* Вы можете использовать git reset, чтобы переместить указатель HEAD к определённому коммиту, что позволит вам "перейти в прошлое" и начать работу от этой точки. Например, `git reset --hard HEAD~1` откатит HEAD к предыдущему коммиту.

3. *Изменение типа сброса (soft, mixed, hard).* Команда `git reset` имеет различные режимы работы, такие как --soft, --mixed и --hard, позволяющие контролировать, какие изменения будут отменены и как. Например, `git reset --soft HEAD~1` вернёт вас к предыдущему коммиту, оставив ваши изменения в рабочем каталоге и индексе, готовые к повторному коммиту.

4. *Отмена нежелательных коммитов.* Вы можете использовать `git reset` для удаления одного или нескольких ненужных коммитов из истории коммитов. Это может быть полезно, когда вы сделали коммиты с ошибками или хотите изменить историю коммитов перед отправкой в удалённый репозиторий.

5. *Решение конфликтов слияний.* В случае возникновения конфликтов при слиянии веток, команда `git reset` может быть использована для перезапуска процесса слияния или перехода к другому состоянию репозитория.

В целом, `git reset` является мощной командой, позволяющей управлять состоянием вашего репозитория Git, отменять изменения и изменять историю коммитов. Однако она также может быть опасной, поэтому важно использовать её осторожно, особенно при выполнении команд с опцией `--hard`, которая может привести к потере данных.

---
